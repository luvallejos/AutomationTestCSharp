trigger:
- master

pool:
  vmImage: 'windows-latest'
  
variables:
  solution: 'AutomationTestCSharp.sln' 
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:
- task: NuGetToolInstaller@1
  displayName: 'Install NuGet'

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    command: 'restore'
    restoreSolution: '$(solution)'
    feedsToUse: 'select'
    includeNuGetOrg: true 

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '/p:Configuration=$(buildConfiguration)'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'
    clean: true

- task: DotNetCoreCLI@2
  displayName: 'Run tests'
  inputs:
    command: 'test'
    projects: '**/*Tests.csproj'
    arguments: >
      --configuration $(BuildConfiguration)
      --logger "trx;LogFileName=tests.trx"
      --results-directory "$(Agent.TempDirectory)\TestResults"
      -- NUnit.TestOutputXml="$(Agent.TempDirectory)\TestResults"

- task: PublishBuildArtifacts@1
  displayName: 'Publish screenshots'
  condition: failed()
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/AutomationTestCSharp/bin/$(buildConfiguration)/Screenshots'
    ArtifactName: 'Screenshots'
    publishLocation: 'Container'    

- task: PublishTestResults@2
  inputs:
    testResultsFormat: 'VSTest'
    condition: always()
    testResultsFiles: '$(Agent.TempDirectory)/TestResults/*.trx'

- task: NuGetCommand@2
  displayName: "Download Extent .NET CLI"
  condition: always()
  inputs:
    command: custom
    arguments: "install extent -Version 0.0.3 -OutputDirectory $(Agent.ToolsDirectory)"
 
- task: PowerShell@2
  displayName: "Generate HTML Test Report (Extent CLI)"
  condition: always()
  inputs:
    targetType: inline
    script: |
      $cli = Get-ChildItem "$(Agent.ToolsDirectory)" -Recurse -Filter "extent.exe" | Select-Object -First 1

      if (-not $cli) {
        Write-Error "extent.exe not found"
        exit 1
      }

      $input  = "$(Agent.TempDirectory)\TestResults"
      $output = "$(Build.ArtifactStagingDirectory)\ExtentReport"

      New-Item -ItemType Directory -Force -Path $output | Out-Null

      Write-Host "Input folder: $input"
      Write-Host "Output folder: $output"
      Write-Host "Using: $($cli.FullName)"

      & $cli.FullName -d $input -o $output -r v3html --merge

      if ($LASTEXITCODE -ne 0) {
        Write-Error "Extent failed with code $LASTEXITCODE"
        exit $LASTEXITCODE
      }
      
- task: PublishBuildArtifacts@1
  displayName: "Publish HTML Report"
  condition: always()
  inputs:
    PathtoPublish: "$(Build.ArtifactStagingDirectory)/HtmlReport"
    ArtifactName: "HtmlTestReport"
    publishLocation: Container
      
- task: PowerShell@2
  displayName: 'Create result tests package'
  condition: always()  
  inputs:
    targetType: 'inline'
    script: |
      $buildConfig = "$(buildConfiguration)"
      $src = "$(Build.SourcesDirectory)"
      $outDir = "$(Build.ArtifactStagingDirectory)"
      
      $screenshotsPath = Join-Path $src "AutomationTestCSharp\bin\$buildConfig\Screenshots"
      $trxPath = "$(Agent.TempDirectory)\TestResults\"
      $htmlReportPath  = "$(Build.ArtifactStagingDirectory)\HtmlReport"

      $tempFolder = Join-Path $outDir "TestResultsStaging"
      if (Test-Path $tempFolder) { Remove-Item $tempFolder -Recurse -Force }
      New-Item -ItemType Directory -Force -Path $tempFolder | Out-Null

       if (Test-Path $screenshotsPath) {
        $destScreens = Join-Path $tempFolder "Screenshots"
        New-Item -ItemType Directory -Force -Path $destScreens | Out-Null
        Copy-Item "$screenshotsPath\*" $destScreens -Recurse -Force
      }

      if (Test-Path $trxPath) {
        $destTrx = Join-Path $tempFolder "Trx"
        New-Item -ItemType Directory -Force -Path $destTrx | Out-Null
        Copy-Item "$trxPath\*" $destTrx -Recurse -Force
      }
      
      if (Test-Path $htmlReportPath) {
        $destHtml = Join-Path $tempFolder "HtmlReport"
        Copy-Item "$htmlReportPath\*" $destHtml -Recurse -Force
      }

      $zipFile = Join-Path $outDir "TestResults_$(Build.BuildId).zip"
      if (Test-Path $zipFile) { Remove-Item $zipFile -Force }
      
      Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
      [System.IO.Compression.ZipFile]::CreateFromDirectory($tempFolder, $zipFile)

      Write-Host "##vso[task.setvariable variable=TEST_RESULTS_ZIP]$zipFile"
      Write-Host "Created zip: $zipFile"
 
- task: PowerShell@2
  displayName: 'Upload results to GitHub Release'
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      $owner = "$(GITHUB_OWNER)"
      $repo  = "$(GITHUB_REPO)"
      $token = "$(GITHUB_TOKEN)"
      $tag   = "test-results"

      $zipPath = "$(TEST_RESULTS_ZIP)"
      if (-not (Test-Path $zipPath)) {
        Write-Host "Zip of results not found: $zipPath"
        exit 0
      }

      $headers = @{ Authorization = "token $token" }

      $releaseUrl = "https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
      $release = Invoke-RestMethod -Uri $releaseUrl -Headers $headers -Method Get

      $releaseId = $release.id
      Write-Host "Release id: $releaseId"

      $fileName = [System.IO.Path]::GetFileName($zipPath)
      $uploadUrl = "https://uploads.github.com/repos/$owner/$repo/releases/$releaseId/assets?name=$fileName"

      $contentType = "application/zip"
      $bytes = [System.IO.File]::ReadAllBytes($zipPath)

      Invoke-RestMethod -Uri $uploadUrl -Headers $headers -Method Post -ContentType $contentType -Body $bytes

      Write-Host "Results uploaded as asset: $fileName"
  env:
    GITHUB_TOKEN: $(GITHUB_TOKEN)