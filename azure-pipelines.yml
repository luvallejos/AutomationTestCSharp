# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

trigger:
- master

pool:
  vmImage: 'windows-latest'
  
variables:
  solution: 'AutomationTestCSharp.sln' 
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:
- task: NuGetToolInstaller@1
  displayName: 'Install NuGet'

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    command: 'restore'
    restoreSolution: '$(solution)'
    feedsToUse: 'select'
    includeNuGetOrg: true 

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '/p:Configuration=$(buildConfiguration)'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'
    clean: true

- task: VSTest@2
  displayName: 'Run tests'
  inputs:
    testSelector: 'testAssemblies'
    testAssemblyVer2: |
      **\*test*.dll
      **\*Test.dll
      **\*Tests.dll
      !**\*TestAdapter.dll
      !**\obj\**
    searchFolder: '$(System.DefaultWorkingDirectory)'
    vsTestVersion: 'latest'
    runInParallel: true
    codeCoverageEnabled: false      

- task: PublishTestResults@2
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '$(Agent.TempDirectory)/TestResults/*.trx'

    
- task: PublishBuildArtifacts@1
  displayName: 'Publish screenshots'
  condition: always() 
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/AutomationTestCSharp/bin/$(buildConfiguration)/Screenshots'
    ArtifactName: 'Screenshots'
    publishLocation: 'Container'
    
- task: PowerShell@2
  displayName: 'Create result tests package'
  condition: always()  
  inputs:
    targetType: 'inline'
    script: |
      $buildConfig = "$(buildConfiguration)"
      $src = "$(Build.SourcesDirectory)"
      $outDir = "$(Build.ArtifactStagingDirectory)"
      
      $screenshotsPath = Join-Path $src "AutomationTestCSharp\bin\$buildConfig\Screenshots"
      $trxPath = "$(Agent.TempDirectory)\TestResults\"

      $tempFolder = Join-Path $outDir "TestResultsStaging"
      if (Test-Path $tempFolder) { Remove-Item $tempFolder -Recurse -Force }
      New-Item -ItemType Directory -Force -Path $tempFolder | Out-Null

       if (Test-Path $screenshotsPath) {
        $destScreens = Join-Path $tempFolder "Screenshots"
        New-Item -ItemType Directory -Force -Path $destScreens | Out-Null
        Copy-Item "$screenshotsPath\*" $destScreens -Recurse -Force
      }

      if (Test-Path $trxPath) {
        $destTrx = Join-Path $tempFolder "Trx"
        New-Item -ItemType Directory -Force -Path $destTrx | Out-Null
        Copy-Item "$trxPath\*" $destTrx -Recurse -Force
      }

      $zipFile = Join-Path $outDir "TestResults_$(Build.BuildId).zip"
      if (Test-Path $zipFile) { Remove-Item $zipFile -Force }
      
      Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
      [System.IO.Compression.ZipFile]::CreateFromDirectory($tempFolder, $zipFile)

      Write-Host "##vso[task.setvariable variable=TEST_RESULTS_ZIP]$zipFile"
 
- task: PowerShell@2
  displayName: 'Upload results to GitHub Release'
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      $owner = "$(GITHUB_OWNER)"
      $repo  = "$(GITHUB_REPO)"
      $token = "$(GITHUB_TOKEN)"
      $tag   = "test-results"

      $zipPath = "$(TEST_RESULTS_ZIP)"
      if (-not (Test-Path $zipPath)) {
        Write-Host "Zip of results not found: $zipPath"
        exit 0
      }

      $headers = @{ Authorization = "token $token" }

      $releaseUrl = "https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
      $release = Invoke-RestMethod -Uri $releaseUrl -Headers $headers -Method Get

      $releaseId = $release.id
      Write-Host "Release id: $releaseId"

      $fileName = [System.IO.Path]::GetFileName($zipPath)
      $uploadUrl = "https://uploads.github.com/repos/$owner/$repo/releases/$releaseId/assets?name=$fileName"

      $contentType = "application/zip"
      $bytes = [System.IO.File]::ReadAllBytes($zipPath)

      Invoke-RestMethod -Uri $uploadUrl -Headers $headers -Method Post -ContentType $contentType -Body $bytes

      Write-Host "Results uploaded as asset: $fileName"
  env:
    GITHUB_TOKEN: $(GITHUB_TOKEN)