trigger:
- master

pool:
  vmImage: 'windows-latest'
  
variables:
  solution: 'AutomationTestCSharp.sln' 
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:
- task: NuGetToolInstaller@1
  displayName: 'Install NuGet'

- task: NuGetCommand@2
  displayName: 'NuGet restore'
  inputs:
    command: 'restore'
    restoreSolution: '$(solution)'
    feedsToUse: 'select'
    includeNuGetOrg: true 

- task: VSBuild@1
  displayName: 'Build solution'
  inputs:
    solution: '$(solution)'
    msbuildArgs: '/p:Configuration=$(buildConfiguration)'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'
    clean: true

- task: VSTest@2
  displayName: 'Run tests'
  inputs:
    testSelector: 'testAssemblies'
    testAssemblyVer2: |
      **\*test*.dll
      **\*Test.dll
      **\*Tests.dll
      !**\*TestAdapter.dll
      !**\obj\**
    searchFolder: '$(System.DefaultWorkingDirectory)'
    vsTestVersion: 'latest'
    runInParallel: true
    codeCoverageEnabled: false         

- task: PublishTestResults@2
  inputs:
    testResultsFormat: 'VSTest'
    condition: always()
    testResultsFiles: '$(Agent.TempDirectory)/TestResults/*.trx'

- task: DotNetCoreCLI@2
  displayName: 'Install ReportGenerator'
  inputs:
    command: 'tool'
    custom: 'install'
    arguments: '--global dotnet-reportgenerator-globaltool'  

- task: PowerShell@2
  displayName: "Generate HTML Test Report"
  condition: always()
  inputs:
    targetType: inline
    script: |
      $trxPath = "$(Build.ArtifactStagingDirectory)"
      $reportPath = "$(Build.ArtifactStagingDirectory)/HtmlReport"

      reportgenerator `
        "-reports:$trxPath/*.trx" `
        "-targetdir:$reportPath" `
        "-reporttypes:Html;HtmlSummary"

      Write-Host "Report generated in: $reportPath"
      
- task: PublishBuildArtifacts@1
  displayName: "Publish HTML Test Report"
  condition: always()
  inputs:
    PathtoPublish: "$(Build.ArtifactStagingDirectory)/HtmlReport"
    ArtifactName: "HtmlTestReport"
    publishLocation: "Container"    
    
- task: PublishBuildArtifacts@1
  displayName: 'Publish screenshots'
  condition: always() 
  inputs:
    PathtoPublish: '$(Build.SourcesDirectory)/AutomationTestCSharp/bin/$(buildConfiguration)/Screenshots'
    ArtifactName: 'Screenshots'
    publishLocation: 'Container'
    
- task: PowerShell@2
  displayName: 'Create result tests package'
  condition: always()  
  inputs:
    targetType: 'inline'
    script: |
      $buildConfig = "$(buildConfiguration)"
      $src = "$(Build.SourcesDirectory)"
      $outDir = "$(Build.ArtifactStagingDirectory)"
      
      $screenshotsPath = Join-Path $src "AutomationTestCSharp\bin\$buildConfig\Screenshots"
      $trxPath = "$(Agent.TempDirectory)\TestResults\"
      $htmlReportPath  = "$(Build.ArtifactStagingDirectory)\HtmlReport"

      $tempFolder = Join-Path $outDir "TestResultsStaging"
      if (Test-Path $tempFolder) { Remove-Item $tempFolder -Recurse -Force }
      New-Item -ItemType Directory -Force -Path $tempFolder | Out-Null

       if (Test-Path $screenshotsPath) {
        $destScreens = Join-Path $tempFolder "Screenshots"
        New-Item -ItemType Directory -Force -Path $destScreens | Out-Null
        Copy-Item "$screenshotsPath\*" $destScreens -Recurse -Force
      }

      if (Test-Path $trxPath) {
        $destTrx = Join-Path $tempFolder "Trx"
        New-Item -ItemType Directory -Force -Path $destTrx | Out-Null
        Copy-Item "$trxPath\*" $destTrx -Recurse -Force
      }
      
      if (Test-Path $htmlReportPath) {
        $destHtml = Join-Path $tempFolder "HtmlReport"
        Copy-Item "$htmlReportPath\*" $destHtml -Recurse -Force
      }

      $zipFile = Join-Path $outDir "TestResults_$(Build.BuildId).zip"
      if (Test-Path $zipFile) { Remove-Item $zipFile -Force }
      
      Add-Type -AssemblyName 'System.IO.Compression.FileSystem'
      [System.IO.Compression.ZipFile]::CreateFromDirectory($tempFolder, $zipFile)

      Write-Host "##vso[task.setvariable variable=TEST_RESULTS_ZIP]$zipFile"
      Write-Host "Created zip: $zipFile"
 
- task: PowerShell@2
  displayName: 'Upload results to GitHub Release'
  condition: always()
  inputs:
    targetType: 'inline'
    script: |
      $owner = "$(GITHUB_OWNER)"
      $repo  = "$(GITHUB_REPO)"
      $token = "$(GITHUB_TOKEN)"
      $tag   = "test-results"

      $zipPath = "$(TEST_RESULTS_ZIP)"
      if (-not (Test-Path $zipPath)) {
        Write-Host "Zip of results not found: $zipPath"
        exit 0
      }

      $headers = @{ Authorization = "token $token" }

      $releaseUrl = "https://api.github.com/repos/$owner/$repo/releases/tags/$tag"
      $release = Invoke-RestMethod -Uri $releaseUrl -Headers $headers -Method Get

      $releaseId = $release.id
      Write-Host "Release id: $releaseId"

      $fileName = [System.IO.Path]::GetFileName($zipPath)
      $uploadUrl = "https://uploads.github.com/repos/$owner/$repo/releases/$releaseId/assets?name=$fileName"

      $contentType = "application/zip"
      $bytes = [System.IO.File]::ReadAllBytes($zipPath)

      Invoke-RestMethod -Uri $uploadUrl -Headers $headers -Method Post -ContentType $contentType -Body $bytes

      Write-Host "Results uploaded as asset: $fileName"
  env:
    GITHUB_TOKEN: $(GITHUB_TOKEN)